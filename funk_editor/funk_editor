#!/usr/bin/python

##    The FUNK Midi Sequencer
##
##    Copyright (C) 2020  Per Sigmond, per@sigmond.no
##
##    This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.

"""                                                                            
Edit midi files

"""
from __future__ import print_function, division
import sys
import argparse
import mido
import zmq
import time
import io
from mido import MidiFile, Message, tempo2bpm, MidiTrack, second2tick
import funk_midievent

DEFAULT_TEMPO = 500000
DEFAULT_TICKS_PER_BEAT = 480

def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    arg = parser.add_argument

    arg('-i', '--data-bus-in',
        dest='data_bus_in',
        default='ipc:///tmp/funk_proxy_out',
        help='path to input socket')

    arg('-o', '--data-bus-out',
        dest='data_bus_out',
        default='ipc:///tmp/funk_proxy_in',
        help='path to output socket')

    arg('-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='print nothing')

    return parser.parse_args()

class funk_editor():

    context = None
    pub_socket = None
    sub_socket = None
    subpoller = None
    midi_file = None
    event_file = None
    event_tracks_changed_since_load = False
    filename = ""
    midievent = None
    
    def __init__(self, zmq_path_in, zmq_path_out):
        
        self.context = zmq.Context()
        self.pub_socket = self.context.socket(zmq.PUB)
        self.pub_socket.connect(zmq_path_out)
        time.sleep(1)
        self.log('started')
        
        self.sub_socket = self.context.socket(zmq.SUB)
        self.sub_socket.connect(zmq_path_in)
        self.sub_socket.setsockopt(zmq.SUBSCRIBE, 'editor')
        self.sub_socket.setsockopt(zmq.SUBSCRIBE, 'all')
        
        self.subpoller = zmq.Poller()
        self.subpoller.register(self.sub_socket, zmq.POLLIN)

        self.midievent = funk_midievent.funk_midievent()

    def log(self, log_msg):    
        topic = 'log'
        msg = {'entity' : 'editor',
               'msg' : log_msg
               }
        self.pub_socket.send_string(topic, flags=zmq.SNDMORE)
        self.pub_socket.send_pyobj(msg)
            
    def error(self, error_msg):
        topic = 'error'
        msg = {'entity' : 'editor',
               'msg' : error_msg
               }
        self.pub_socket.send_string(topic, flags=zmq.SNDMORE)
        self.pub_socket.send_pyobj(msg)
    

    def send_ctrl_msg(self, topic, msg):
        print('Sending ctrl message [' + repr(topic) + ']')
        self.pub_socket.send_string(topic, flags=zmq.SNDMORE)
        self.pub_socket.send_pyobj(msg)
        
    def handle_ctrl_msg(self, topic, msg):
        print('Got ctrl message')
        print('topic ' + repr(topic) + ' msg ' + repr(msg))
        if topic == 'editor':
            if msg['command'] == 'open':
                self.handle_open(msg)
            elif msg['command'] == 'save':
                self.handle_save(msg)
            elif msg['command'] == 'play':
                self.handle_play(msg)
            elif msg['command'] == 'cut_area':
                self.handle_cut_area(msg)
            elif msg['command'] == 'paste_area':
                self.handle_paste_area(msg)
            else:
                print('Unknown editor command ' + repr(msg['command']))
                self.log('Unknown editor command ' + repr(msg['command']))
        elif topic == 'all':
            if ctrl_msg['command'] == 'quit':
                print ('Quitting')
                exit(0)

    def handle_open(self, msg):
        if msg['type'] ==  'file':
            self.log('opening ' + self.filename)
            self.filename = msg['name']
            self.midi_file = msg['obj']
            self.event_file = self.midievent.file2events(self.midi_file, self.filename)
            # event file and midi file is the same:
            self.event_tracks_changed_since_load = False
            self.load_file_to_player()
            self.client_file_loaded()
        else:
            self.log('Unknown open type ' + repr(msg['type']))

    def handle_save(self, msg):
        if msg['type'] ==  'file':
            self.log('saving ' + self.filename)
            self.midi_file = self.midievent.events2file(self.event_file)
            obj = {'command': 'download',
                   'what': 'file',
                   'name': self.filename,
                   'obj': self.midi_file
                   }
            self.send_ctrl_msg('controller', obj)
        else:
            self.log('Unknown open type ' + repr(msg['type']))

    def handle_play(self, msg):
        if msg['what'] ==  'file':
            if self.event_tracks_changed_since_load:
                self.load_file_to_player()
            obj = {'command': 'play',
                   'start' : msg['start']
                   }
            self.send_ctrl_msg('player', obj)
        else:
            self.log('Unknown play what ' + repr(msg['what']))
                    
    def handle_cut_area(self, msg):
        print('editor got ' + repr(msg))
        area = msg['area']
        remove_space = msg['remove_space']
        self.event_file = self.midievent.cut_area(self.event_file, area, remove_space)
        tracks = []
        for i in range(area['track_start'], area['track_stop']):
            tracks.append(self.event_file['tracks'][i])
        self.client_tracks_changed(tracks)
        self.event_tracks_changed_since_load = tracks
        self.load_file_to_player()

    def handle_paste_area(self, msg):
        print('editor got ' + repr(msg))
        from_area = msg['from']
        to_area = msg['to']
        insert_space = msg['insert_space']
        merge = msg['merge']
        cut_or_copy = msg['cut_or_copy']
        self.event_file = self.midievent.paste_area(self.event_file, from_area, to_area, insert_space, merge, cut_or_copy)
        tracks = []
        for i in range(to_area['track_start'], to_area['track_stop']):
            tracks.append(self.event_file['tracks'][i])
        self.client_tracks_changed(tracks)
        self.event_tracks_changed_since_load = tracks
        self.load_file_to_player()

    def load_file_to_player(self):
        if self.event_tracks_changed_since_load:
            for track in self.event_tracks_changed_since_load:
                self.midi_file.tracks[track['index']] = self.midievent.events2track(track)
        obj = {'command': 'load',
               'what': 'file',
               'obj': self.midi_file
               }
        self.send_ctrl_msg('player', obj)
        self.event_tracks_changed_since_load = False

    def client_file_loaded(self):
        obj = {'command' : 'file_loaded',
               'filename' : self.filename,
               'file' : self.encode_file_for_client()
               }
        self.send_ctrl_msg('controller', obj)

    def client_tracks_changed(self, tracks):
        obj = {'command' : 'tracks_changed',
               'tracks' : self.encode_tracks_for_client(tracks)
               }
        self.send_ctrl_msg('controller', obj)

    def encode_file_for_client(self):
        return self.event_file

    def encode_tracks_for_client(self, obj):
        return obj

def main():

    editor = funk_editor(args.data_bus_in, args.data_bus_out)
    
    while 1:
        try:
            clientsock = dict(editor.subpoller.poll(None))
            if clientsock:
                if editor.sub_socket in clientsock and clientsock[editor.sub_socket] == zmq.POLLIN:
                    topic = editor.sub_socket.recv()
                    ctrl_msg = editor.sub_socket.recv_pyobj()
                    editor.handle_ctrl_msg(topic, ctrl_msg)
        except:
            editor.error('editor got exception:' + repr(sys.exc_info()))
            exit(0)
    

args = parse_args()

if args.quiet:
    def print(*args):
        pass

main()
