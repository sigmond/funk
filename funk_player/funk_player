#!/usr/bin/python
"""                                                                            
Play MIDI file object to message bus

Example:

    funk_player

"""
from __future__ import print_function, division
import sys
import argparse
import mido
import zmq
import time
from mido import MidiFile, Message, MetaMessage, tempo2bpm

def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    arg = parser.add_argument

    arg('-i', '--data-bus-in',
        dest='data_bus_in',
        default='ipc:///tmp/data_bus_proxy_out',
        help='path to input socket')

    arg('-o', '--data-bus-out',
        dest='data_bus_out',
        default='ipc:///tmp/data_bus_proxy_in',
        help='path to output socket')

    arg('-m', '--print-messages',
        dest='print_messages',
        action='store_true',
        default=False,
        help='Print messages as they are played back')

    arg('-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='print nothing')

    return parser.parse_args()


def connect_subscriber(path):
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.connect (path)
    return socket

def connect_publisher(path):
    context = zmq.Context()
    socket = context.socket(zmq.PUB)
    socket.connect (path)
    return socket

def subscribe(socket, topic):
    socket.setsockopt(zmq.SUBSCRIBE, topic)

def log(log_msg):
    global pub_socket
    
    topic = 'log'
    msg = {'entity' : 'player',
           'msg' : log_msg
           }
    pub_socket.send_string(topic, flags=zmq.SNDMORE)
    pub_socket.send_pyobj(msg)
    
def error(error_msg):
    global pub_socket
    
    topic = 'error'
    msg = {'entity' : 'player',
           'msg' : error_msg
           }
    pub_socket.send_string(topic, flags=zmq.SNDMORE)
    pub_socket.send_pyobj(msg)

def send_ctrl_msg(socket, topic, ctrl_msg):
##    print('Sending ctrl message [' + repr(topic) + '] ' + repr(ctrl_msg))
    socket.send_string(topic, flags=zmq.SNDMORE)
    socket.send_pyobj(ctrl_msg)

def send_panic():
    global pub_socket
    obj = {'command': 'panic'}
    send_ctrl_msg(pub_socket, 'outputter', obj)

def send_time(start_time, start_play):
    global pub_socket
    obj = {'unit': 'seconds',
           'time': time.time() - start_time + start_play
           }
    send_ctrl_msg(pub_socket, 'time', obj)


def poll_ctrl_command():
    global playing
    global ctrl_socket
    
    try:
        clientsock = dict(subpoller.poll(0.001))
        
        if clientsock:
            if ctrl_socket in clientsock and clientsock[ctrl_socket] == zmq.POLLIN:
                topic = ctrl_socket.recv()
                print('got topic ' + repr(topic))
                ctrl_msg = ctrl_socket.recv_pyobj()
                if handle_ctrl_msg(topic, ctrl_msg) == 'stop':
                    playing = False
                    return 'stop'
                return ''
    except:
        error('got exception:' + sys.exc_info()[0])
    

def play(midi_file,  message_track_number_list, start_play, time_unit, meta_messages=False):
    global playing
    global ctrl_socket

    start_time = time.time()
    input_time = 0.0

    for msg, track_number in map(None, midi_file, message_track_number_list):
        input_time += msg.time


        playback_time = time.time() - start_time + start_play
        duration_to_next_event = input_time - playback_time

##        print('input_time ' + repr(input_time) + ' start_play ' + repr(start_play) + ' sleep duration ' + repr(duration_to_next_event))
        
        if (input_time > 0) and (input_time < start_play):
            continue

        while duration_to_next_event > 0.1:
            command = poll_ctrl_command()
            if command == 'stop':
                return
            send_time(start_time, start_play)
            time.sleep(0.1)
            duration_to_next_event = duration_to_next_event - 0.1
            
        if duration_to_next_event > 0.0:
            send_time(start_time, start_play)
            time.sleep(duration_to_next_event)
            
        command = poll_ctrl_command()
        if command == 'stop':
            return
            
        if isinstance(msg, MetaMessage) and not meta_messages:
            continue
        else:
            yield {'msg' : msg, 'track_number' : track_number}

def play_file(midi_file, start_time, time_unit, print_messages):
    global muted_channels
    global muted_tracks
    global playing
    global ctrl_socket
    global pub_socket
    
    playing = True
    print('Playing')
    length = midi_file.length
    print('Song length: {} minutes, {} seconds.'.format(
            int(length / 60),
            int(length % 60)))
    print('Tracks:')
    for i, track in enumerate(midi_file.tracks):
        print('  {:2d}: {!r}'.format(i, track.name.strip()))

    ## Instant mute/unmute track
    track_file = mido.MidiFile(type=1)
    print('track_file ' + repr(track_file))
    for i, channel_track in enumerate(midi_file.tracks):
##        print('track ' + repr(i) + ' ' + repr(channel_track))
        track_track = mido.MidiTrack()
        for msg in channel_track:
            track_msg = msg.copy()
            if hasattr(track_msg, 'channel'):
##                print('changing from ' + repr(getattr(msg,'channel')) + ' to ' + repr(i))
                setattr(track_msg, 'channel', i)
##                print('msg ' + repr(msg))
##                print('track_msg ' + repr(track_msg))
            track_track.append(track_msg)
        track_file.tracks.append(track_track)

##    print('midi_file ' + repr(midi_file))
##    print('track_file ' + repr(track_file))
    
    track_number_messages = []
    for msg in track_file:
        if hasattr(msg, 'channel'):
            track_number_messages.append(getattr(msg,'channel'))
        else:
            track_number_messages.append(None)
    
##    print('track number messages ' + repr(len(track_number_messages)))

    for message_dict in play(midi_file, track_number_messages, start_time, time_unit, meta_messages=True):
        if print_messages:
            print(repr(message_dict))

        message = message_dict['msg']
        track_number = message_dict['track_number']
        if isinstance(message, Message):
            muted = False
            if hasattr(message, 'channel'):
                if getattr(message, 'channel') in muted_channels:
                    muted = True
            if track_number in muted_tracks:
                muted = True

            if not muted:
                pub_socket.send_string('midi_play', flags=zmq.SNDMORE)
                pub_socket.send_pyobj(message)
        elif message.type == 'set_tempo':
            print('Tempo changed to {:.1f} BPM.'.format(
                tempo2bpm(message.tempo)))
        

    print()
    playing = False


def track2file(track):
    midi_file = MidiFile(type=1)
    midi_file.tracks.append(track)
    return midi_file


def handle_load_command(msg):
    global midi_file
    
    print('Got load command')
    if msg['type'] == 'track':
        print ('converting to file')
        midi_file = track2file(msg['midi_obj'])
        print('midi_file ' + repr(midi_file))
    elif msg['type'] == 'file':
        midi_file = msg['midi_obj']

    return ''
        
def handle_play_command(msg):
    global midi_file
    global muted_channels
    global muted_tracks
    
    print('Got play command')
    if midi_file != None:
        print ('calling play')
        play_file(midi_file, msg['start'], msg['unit'], args.print_messages)

    midi_file = None
    muted_channels = []
    muted_tracks = []
    return ''
        
def handle_channel_command(msg):
    global muted_channels
    
    print('Got channel command')
    muted_channels = msg['muted']
    return ''
        
def handle_track_command(msg):
    global muted_tracks
    
    print('Got track command')
    muted_tracks = msg['muted']
    return ''
        
def handle_stop_command(msg):
    global midi_file
    global muted_channels
    global muted_tracks
    
    print('Got stop command, playing = ' + repr(playing))
    midi_file = None
    muted_channels = []
    muted_tracks = []
    send_panic()
    return 'stop'
        
def handle_ctrl_msg(topic, msg):
    print('Got ctrl message')
    print('topic ' + repr(topic) + ' msg ' + repr(msg))
    if topic == 'player':
        if msg['command'] == 'load':
            return handle_load_command(msg)
        if msg['command'] == 'play':
            return handle_play_command(msg)
        elif msg['command'] == 'stop':
            return handle_stop_command(msg)
        elif msg['command'] == 'channel':
            return handle_channel_command(msg)
        elif msg['command'] == 'track':
            return handle_track_command(msg)
        else:
            print('Unknown ' + topic + ' command ' + repr(msg['command']))
    elif topic == 'all':
        if ctrl_msg['command'] == 'quit':
            print ('Quitting')
            exit(0)
    
    
def main():
    global ctrl_socket
    global pub_socket
    global playing
    global midi_file
    global muted_channels
    global muted_tracks
    global subpoller
    
    ctrl_socket = connect_subscriber(args.data_bus_in)
    pub_socket = connect_publisher(args.data_bus_out)
    
    subscribe(ctrl_socket, 'all')
    subscribe(ctrl_socket, 'player')
    
    subpoller = zmq.Poller()
    subpoller.register(ctrl_socket, zmq.POLLIN)

    playing = False
    midi_file = None
    muted_channels = []
    muted_tracks = []

    while 1:
        try:
            clientsock = dict(subpoller.poll(None))

            if clientsock:
                if ctrl_socket in clientsock and clientsock[ctrl_socket] == zmq.POLLIN:
                    topic = ctrl_socket.recv()
                    ctrl_msg = ctrl_socket.recv_pyobj()
                    handle_ctrl_msg(topic, ctrl_msg)
        except:
            error('got exception:' + sys.exc_info()[0])

args = parse_args()

if args.quiet:
    def print(*args):
        pass

main()
