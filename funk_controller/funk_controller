#!/usr/bin/python
"""                                                                            
Send control sequences to other entities

"""
from __future__ import print_function, division
import sys
import argparse
import mido
import time
import io
import os
from mido import MidiFile, Message, tempo2bpm, MidiTrack, second2tick
import json
import ast
import binascii
import funk_com
    
def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    arg = parser.add_argument

    arg('-i', '--data-bus-in',
        dest='data_bus_in',
        default='ipc:///tmp/data_bus_proxy_out',
        help='path to input socket')

    arg('-o', '--data-bus-out',
        dest='data_bus_out',
        default='ipc:///tmp/data_bus_proxy_in',
        help='path to output socket')

    arg('-p', '--websocket-port',
        dest='ws_port',
        default=9001,
        help='websocket port')

    arg('-t', '--websocket-host',
        dest='ws_host',
        default='127.0.0.1',
        help='websocket host')

    arg('-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='print nothing')

    return parser.parse_args()

class funk_controller():

    com = None

    def __init__(self, zmq_path_in, zmq_path_out, websocket_port=9001, websocket_host='127.0.0.1'):

        self.com = funk_com.funk_com(self, zmq_path_in, zmq_path_out, websocket_port, websocket_host)
        self.com.subscribe('all')
        self.com.subscribe('controller')

    def handle_ctrl_message(topic, msg):
        print('Got ctrl message')
        print('topic ' + repr(topic) + ' msg ' + repr(msg))
        if topic == 'controller':
            if msg['command'] == 'load':
                handle_load(msg)
            elif msg['command'] == 'play':
                handle_play(msg)
            elif msg['command'] == 'stop':
                handle_stop(msg)
            elif msg['command'] == 'channel':
                handle_channel(msg)
            elif msg['command'] == 'track':
                handle_track(msg)
            elif msg['command'] == 'record':
                handle_record(msg)
            elif msg['command'] == 'loopback':
                handle_loopback(msg)
            elif msg['command'] == 'panic':
                handle_panic()
            elif msg['command'] == 'reset':
                handle_reset()
            else:
                print('Unknown controller command ' + repr(msg['command']))
        elif topic == 'all':
            if msg['command'] == 'quit':
                print ('Killing capturer')
                os.system('pkill funk_capturer')
                print ('Killing data_bus_proxy')
                os.system('pkill data_bus_proxy')
                print ('Quitting')
                exit(0)
        
    
def handle_client_ctrl_message(message):
    msg = message['msg']
    if msg['type'] == 'ctrl':
        self.handle_ctrl_message(message['topic'], message['msg']) 
    elif msg['command'] == 'file':
        print ('got file')
        decoded = binascii.a2b_base64(msg['content'])
        midi_file = mido.MidiFile(file=io.BytesIO(decoded))
        print('midi file ' + repr(midi_file))
    else:
        print('sending ctrl message to bus')
        send_ctrl_msg(pub_socket, message['topic'], message['msg'])

def handle_load(msg):
    print('handle_load')
    if msg['what'] == 'disc':
        midi_obj = MidiFile(msg['path'])
        obj = {'command' : 'load',
               'type': 'file',
               'midi_obj': midi_obj
               }
    elif msg['what'] == 'file':
        topic = 'file'
        obj = {'command': 'load',
               'type': 'file',
               'midi_obj': msg['obj']
               }
    elif msg['what'] == 'track':
        obj = {'command': 'load',
               'type': 'track',
               'midi_obj': msg['obj']
               }

    print('Calling send_ctrl_msg')
    send_ctrl_msg(pub_socket, 'player', obj)

def handle_play(msg):
    print('handle_play')
    obj = {'command': 'play',
           'start' : msg['start'],
           'unit' : msg['unit']
           }
    send_ctrl_msg(pub_socket, 'player', obj)
    
    
def handle_stop(msg):
    obj = {'command': 'stop'}
    send_ctrl_msg(pub_socket, 'player', obj)
    send_ctrl_msg(pub_socket, 'recorder', obj)
    
def handle_channel(msg):
    print('handle_channel')
    obj = msg
    send_ctrl_msg(pub_socket, 'player', obj)
    
def handle_track(msg):
    print('handle_track')
    obj = msg
    send_ctrl_msg(pub_socket, 'player', obj)
    
def handle_panic():
    obj = {'command': 'panic'}
    send_ctrl_msg(pub_socket, 'outputter', obj)
    
def handle_reset():
    obj = {'command': 'reset'}
    send_ctrl_msg(pub_socket, 'outputter', obj)
    
def handle_record(msg):
    obj = {'command': 'record'}
    send_ctrl_msg(pub_socket, 'recorder', obj)
    obj = {'command': 'play'}
    send_ctrl_msg(pub_socket, 'player', obj)
    
def handle_loopback(msg):
    send_ctrl_msg(pub_socket, 'capturer', obj)
    

    



def main():

    controller = funk_controller(args.data_bus_in, args.data_bus_out, args.ws_port, args.ws_host)
    
    while 1:
        try:
            messages = self.com.poll_messages()
            if messages:
                for message in messages:
                    self.handle_message(message['topic'], message['obj'])
        except:
            print('controller got exception')
            exit(0)
    

args = parse_args()

if args.quiet:
    def print(*args):
        pass

main()
