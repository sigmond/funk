#!/usr/bin/python
"""                                                                            
Send control sequences to other entities

"""
from __future__ import print_function, division
import sys
import argparse
import mido
import time
import io
import os
from mido import MidiFile, Message, tempo2bpm, MidiTrack, second2tick
import json
import ast
import binascii
import funk_com
    
def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    arg = parser.add_argument

    arg('-i', '--data-bus-in',
        dest='data_bus_in',
        default='ipc:///tmp/data_bus_proxy_out',
        help='path to input socket')

    arg('-o', '--data-bus-out',
        dest='data_bus_out',
        default='ipc:///tmp/data_bus_proxy_in',
        help='path to output socket')

    arg('-p', '--websocket-port',
        dest='ws_port',
        default=9001,
        help='websocket port')

    arg('-t', '--websocket-host',
        dest='ws_host',
        default='127.0.0.1',
        help='websocket host')

    arg('-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='print nothing')

    return parser.parse_args()

class funk_controller():

    com = None

    def __init__(self, zmq_path_in, zmq_path_out, websocket_port=9001, websocket_host='127.0.0.1'):

        self.com = funk_com.funk_com(self, zmq_path_in, zmq_path_out, websocket_port, websocket_host)
        self.com.subscribe('all')
        self.com.subscribe('controller')
        self.com.subscribe('recorded')
        self.com.subscribe('time')
        self.com.subscribe('error')
        self.com.subscribe('log')

    def error(msg):
        topic = 'error'
        msg = {'entity' : 'controller',
               'msg' : msg
               }
        self.handle_error(msg)

    def log(msg):
        topic = 'log'
        msg = {'entity' : 'controller',
               'msg' : msg
               }
        self.handle_log(msg)

    def handle_ctrl_message(topic, msg):
        print('Got ctrl message')
        print('topic ' + repr(topic) + ' msg ' + repr(msg))
        if topic == 'controller':
            if msg['command'] == 'open_output_port':
                # someone (e.g. the client) wants to open a midi port for output
                self.handle_open_output_port(msg)
            elif msg['command'] == 'open_input_port':
                # someone (e.g. the client) wants to open a midi port for input
                self.handle_open_input_port(msg)
            elif msg['command'] == 'edit':
                # client is uploading something (e.g. a file)
                # to be remembered by the editor
                self.handle_edit(msg)
            elif msg['command'] == 'save':
                # client wants to get hold of something (e.g. a file)
                self.handle_save(msg)
            elif msg['command'] == 'download':
                # someone (e.g. the editor) wants to send something (e.g. a file)
                # to the client for saving
                self.handle_download(msg)
            elif msg['command'] == 'load':
                # someone (e.g. the editor or the client) wants to prepare something (e.g. a file)
                # for playing
                self.handle_load(msg)
            elif msg['command'] == 'play':
                # someone (e.g. the client) wants to start playing a loaded object (e.g. a file)
                self.handle_play(msg)
            elif msg['command'] == 'stop':
                # someone (e.g. the client) wants to stop playing and/or recording
                self.handle_stop(msg)
            elif msg['command'] == 'channel':
                # someone (e.g. the client) wants to change the play-mode for specific channels (e.g. mute)
                self.handle_channel(msg)
            elif msg['command'] == 'track':
                # someone (e.g. the client) wants to change the play-mode for specific tracks (e.g. mute)
                self.handle_track(msg)
            elif msg['command'] == 'record':
                # someone (e.g. the client) wants to start playing a loaded object (e.g. a file) and also record
                self.handle_record(msg)
            elif msg['command'] == 'loopback':
                # someone (e.g. the client) wants to change the loopback status of the outputter (on/off)
                # (loopback on means that events from the capturer are forwarded to the out device in real time by the outputter)
                self.handle_loopback(msg)
            elif msg['command'] == 'panic':
                # someone (e.g. the client) wants to stop all sound from the midi module
                self.handle_panic()
            elif msg['command'] == 'reset':
                # someone wants to reset the midi module
                self.handle_reset()
            else:
                print('Unknown controller command ' + repr(msg['command']))
        elif topic == 'time':
            # someone (the player) has sent information about what position in the song (midi file) we are playing right now
            self.handle_time(msg)
        elif topic == 'error':
            # someone has experienced an error
            self.handle_error(msg)
        elif topic == 'log':
            # someone sent a log message
            self.handle_log(msg)
        elif topic == 'all':
            if msg['command'] == 'quit':
                # someone (e.g. the client) wants everything to stop/exit
                print ('Killing capturer')
                os.system('pkill funk_capturer')
                print ('Killing data_bus_proxy')
                os.system('pkill data_bus_proxy')
                print ('Quitting')
                exit(0)

    def handle_error(msg):
        print(repr(msg))
        self.com.send_client_error_msg('error', msg)
        
    def handle_log(msg):
        print(repr(msg))
        self.com.send_client_log_msg('log', msg)
            

    def handle_open_output_port(msg):
        obj = {'command': 'open_output_port',
               'port' : msg['port']
               }
        self.com.send_bus_msg('outputter', obj)
    
    def handle_open_input_port(msg):
        # this is supposed to bring the capturer out of the midi-read loop and
        # wait for a bus message:
        os.system('pkill -HUP funk_capturer')
        obj = {'command': 'open_input_port',
               'port' : msg['port']
               }
        self.com.send_bus_msg('capturer', obj)
    
    def handle_edit(msg):
        print('handle_edit')
        if msg['what'] == 'file':
            topic = 'file'
            obj = {'command': 'edit',
                   'type': 'file',
                   'name' : msg['name']
                   'midi_obj': msg['obj']
                   }
        else:
            print('unknown "what" ' + repr(what))
            return
        print('Calling send_bus_msg')
        self.com.send_bus_msg('editor', obj)
        
    def handle_save(msg):
        print('handle_save')
        if msg['what'] == 'file':
            topic = 'file'
            obj = {'command': 'save',
                   'type': 'file'
                   }
        else:
            print('unknown "what" ' + repr(what))
            return
        print('Calling send_bus_msg')
        self.com.send_bus_msg('editor', obj)
        
    def handle_download(msg):
        print('handle_download')
        self.com.send_client_ctrl_msg('download', msg)
        
    def handle_load(msg):
        print('handle_load')
        if msg['what'] == 'disc':
            midi_obj = MidiFile(msg['path'])
            obj = {'command' : 'load',
                   'type': 'file',
                   'midi_obj': midi_obj
                   }
        elif msg['what'] == 'file':
            topic = 'file'
            obj = {'command': 'load',
                   'type': 'file',
                   'midi_obj': msg['obj']
                   }
        elif msg['what'] == 'track':
            obj = {'command': 'load',
                   'type': 'track',
                   'midi_obj': msg['obj']
                   }
        else:
            print('unknown "what" ' + repr(what))
            return

        print('Calling send_bus_msg')
        self.com.send_bus_msg('player', obj)

    def handle_play(msg):
        print('handle_play')
        obj = {'command': 'play',
               'start' : msg['start'],
               'unit' : msg['unit']
               }
        self.com.send_bus_msg('player', obj)
    
    
    def handle_stop(msg):
        obj = {'command': 'stop'}
        self.com.send_bus_msg('player', obj)
        self.com.send_bus_msg('recorder', obj)
    
    def handle_channel(msg):
        print('handle_channel')
        obj = msg
        self.com.send_bus_msg('player', obj)
    
    def handle_track(msg):
        print('handle_track')
        obj = msg
        self.com.send_bus_msg('player', obj)
    
    def handle_panic():
        obj = {'command': 'panic'}
        self.com.send_bus_msg('outputter', obj)
    
    def handle_reset():
        obj = {'command': 'reset'}
        self.com.send_bus_msg('outputter', obj)
    
    def handle_record(msg):
        obj = {'command': 'record',
               'start' : msg['start'],
               'unit' : msg['unit']
               }
        self.com.send_bus_msg('recorder', obj)
        obj = {'command': 'play'}
        self.com.send_bus_msg('player', obj)
    
    def handle_loopback(msg):
        obj = {'command': 'loopback',
               'onoff' : msg['onoff']
               }
        self.com.send_bus_msg('outputter', obj)
    
    def handle_time(msg):
        self.com.send_client_time_msg('time', msg)
    



def main():

    controller = funk_controller(args.data_bus_in, args.data_bus_out, args.ws_port, args.ws_host)
    
    while 1:
        try:
            messages = self.com.poll_messages()
            if messages:
                for message in messages:
                    self.handle_message(message['topic'], message['obj'])
        except:
            error('got exception:' + sys.exc_info()[0])
            exit(0)
    

args = parse_args()

if args.quiet:
    def print(*args):
        pass

main()
