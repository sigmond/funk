#!/usr/bin/python
"""                                                                            
Play MIDI messages on output port

Example:

    funk_player

"""
from __future__ import print_function, division
import sys
import argparse
import mido
import zmq
from mido import MidiFile, Message, tempo2bpm

def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    arg = parser.add_argument

    arg('-i', '--data-bus-in',
        dest='data_bus_in',
        default='ipc:///tmp/data_bus_proxy_out',
        help='path to input socket')

    arg('-o', '--data-bus-out',
        dest='data_bus_out',
        default='ipc:///tmp/data_bus_proxy_in',
        help='path to output socket')

    arg('-p', '--midi-port-out',
        dest='midi_port_out',
        default=None,
        help='midi output port')

    arg('-m', '--print-messages',
        dest='print_messages',
        action='store_true',
        default=False,
        help='Print messages as they are played')

    arg('-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='print nothing')

    return parser.parse_args()


def connect_subscriber(path):
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.connect (path)
    return socket

def subscribe(socket, topic):
    socket.setsockopt(zmq.SUBSCRIBE, topic)

def open_output(port):
    return mido.open_output(port)

def send_ctrl_msg(socket, topic, ctrl_msg):
    socket.send_string(topic, flags=zmq.SNDMORE)
    socket.send_pyobj(ctrl_msg)
    
def log(log_msg):
    global pub_socket
    
    topic = 'log'
    msg = {'entity' : 'outputter',
           'msg' : log_msg
           }
    pub_socket.send_string(topic, flags=zmq.SNDMORE)
    pub_socket.send_pyobj(msg)
    
def error(error_msg):
    global pub_socket

    topic = 'error'
    msg = {'entity' : 'outputter',
           'msg' : error_msg
           }
    pub_socket.send_string(topic, flags=zmq.SNDMORE)
    pub_socket.send_pyobj(msg)
    
def handle_panic(port):
    print('handle_panic')
    port.panic()
    
def handle_loopback(msg):
    global loopback
    print('handle_loopback')
    if msg['onoff'] == 'on':
        loopback = True
    else:
        loopback = False

def handle_open_output_port(msg):
    global outport
    print('handle_open_output_port')
    if outport != None:
        mido.close_output(outport)
    try:
        outport = open_port(msg['port'])
    except:
        error('cannot open output port ' + repr(msg['port'])


def handle_midi_msg(port, topic, midi_msg):
    global loopback
    print('Got midi message')
    sys.stdout.write('topic ' + repr(topic) + ' msg ' + repr(midi_msg) + '\n')
    sys.stdout.flush()
    if topic != 'midi_rec' or loopback:
        port.send(midi_msg)
    
    
def handle_ctrl_msg(topic, ctrl_msg):
    global outport
    
    print('Got ctrl message')
    print('topic ' + repr(topic) + ' msg ' + repr(ctrl_msg))
    if topic == 'outputter':
        if ctrl_msg['command'] == 'panic':
            handle_panic(outport)
        elif ctrl_msg['command'] == 'loopback':
            handle_loopback(ctrl_msg)
        elif ctrl_msg['command'] == 'open_output_port':
            handle_open_output_port(ctrl_msg)
    elif topic == 'all':
        if ctrl_msg['command'] == 'quit':
            print ('Quitting')
            exit(0)
    

def main():
    global outport
    global loopback
    global pub_socket
    
    pub_socket = connect_publisher(args.data_bus_out)

    outport = None
    loopback = True
    
    try:
        if args.midi_port_out != None:
            outport = mido.open_output(args.midi_port_out)
    except:
        msg = 'Error opening output port ' + args.midi_port_out
        print(msg)
        error(msg)
        exit(-1)
        
    midi_socket = connect_subscriber(args.data_bus_in)
    ctrl_socket = connect_subscriber(args.data_bus_in)
    
    subscribe(midi_socket, 'midi_play')
    subscribe(midi_socket, 'midi_rec')
    subscribe(ctrl_socket, 'all')
    subscribe(ctrl_socket, 'outputter')
## Poll loop:
## Receive events for playing on midi_socket
## - events on 'midi_play' topic should be played immediately
## - events on 'midi_rec' topic (typically loopback from keyboard) should be played immediately if loopback is on
## Receive control-messages on ctrl_socket
## - it is important that control messages are handled asap (e.g. stop play or panic)
## - typical ctrl messages: open_output_port (name), loopback (on/off), panic
    subpoller = zmq.Poller()
    subpoller.register(midi_socket, zmq.POLLIN)
    subpoller.register(ctrl_socket, zmq.POLLIN)
    
    while 1:
        try:
            clientsock = dict(subpoller.poll(None))

            if clientsock:
                if midi_socket in clientsock and clientsock[midi_socket] == zmq.POLLIN:
                    topic = midi_socket.recv()
                    midi_msg = midi_socket.recv_pyobj()
                    handle_midi_msg(outport, topic, midi_msg) 
                if ctrl_socket in clientsock and clientsock[ctrl_socket] == zmq.POLLIN:
                    topic = ctrl_socket.recv()
                    ctrl_msg = ctrl_socket.recv_pyobj()
                    handle_ctrl_msg(topic, ctrl_msg)     
        except:
            error('got exception:' + sys.exc_info()[0])
            outport.close()
            exit(0)

args = parse_args()

if args.quiet:
    def print(*args):
        pass

main()
