#!/usr/bin/python
"""                                                                            
Grab MIDI events and send to message bus

"""
from __future__ import print_function, division
import sys
import argparse
import mido
import zmq
import time
import signal
from mido import MidiFile, Message, tempo2bpm

def parse_args():
    parser = argparse.ArgumentParser(description=__doc__)
    arg = parser.add_argument

    arg('-i', '--data-bus-in',
        dest='data_bus_in',
        default='ipc:///tmp/data_bus_proxy_out',
        help='path to input socket')

    arg('-o', '--data-bus-out',
        dest='data_bus_out',
        default='ipc:///tmp/data_bus_proxy_in',
        help='path to output socket')

    arg('-p', '--midi-port-in',
        dest='midi_port_in',
        default=None,
        help='midi input port')

    arg('-m', '--print-messages',
        dest='print_messages',
        action='store_true',
        default=False,
        help='Print messages as they are played back')

    arg('-q', '--quiet',
        dest='quiet',
        action='store_true',
        default=False,
        help='print nothing')

    return parser.parse_args()

def receiveSignal(signalNumber, frame):
    print('got signal')
    topic = ctrl_socket.recv()
    ctrl_msg = ctrl_socket.recv_pyobj()
    handle_ctrl_msg(topic, ctrl_msg)
    raise Exception('inport')
    
    
def connect_publisher(path):
    context = zmq.Context()
    socket = context.socket(zmq.PUB)
    socket.connect (path)
    return socket

def connect_subscriber(path):
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.connect (path)
    return socket

def subscribe(socket, topic):
    socket.setsockopt(zmq.SUBSCRIBE, topic)

def open_input(port):
    return mido.open_input(port)


def send_rec_msg(socket, midi_msg):
    print('Sending midi message')
    socket.send_string('midi_rec', flags=zmq.SNDMORE)
    socket.send_pyobj(midi_msg)
    
    
def log(log_msg):
    global pub_socket
    
    topic = 'log'
    msg = {'entity' : 'capturer',
           'msg' : log_msg
           }
    pub_socket.send_string(topic, flags=zmq.SNDMORE)
    pub_socket.send_pyobj(msg)
    
def error(error_msg):
    global pub_socket
    
    topic = 'error'
    msg = {'entity' : 'capturer',
           'msg' : error_msg
           }
    pub_socket.send_string(topic, flags=zmq.SNDMORE)
    pub_socket.send_pyobj(msg)

def send_ctrl_msg(socket, topic, ctrl_msg):
    socket.send_string(topic, flags=zmq.SNDMORE)
    socket.send_pyobj(ctrl_msg)

def handle_list_input_ports(msg):
    global pub_socket
    global inport_name
    
    ports = mido.get_input_names()
    msg = {'command' : 'input_ports',
           'input_ports' : ports,
           'current_port' : inport_name
           }
    send_ctrl_msg(pub_socket, 'controller', msg)

def handle_open_input_port(msg):
    global inport
    global inport_name
    
    print('handle_open_input_port')
    if inport != None:
        inport.close()
    try:
        inport = open_input(msg['port'])
        inport_name = msg['port']
    except:
        error('cannot open input port ' + repr(msg['port']))

def handle_ctrl_msg(topic, ctrl_msg):
    global inport
    
    print('Got ctrl message')
    print('topic ' + repr(topic) + ' msg ' + repr(ctrl_msg))
    if topic == 'capturer':
        if ctrl_msg['command'] == 'open_input_port':
            handle_open_input_port(ctrl_msg)
        elif ctrl_msg['command'] == 'list_input_ports':
            handle_list_input_ports(ctrl_msg)
        else:
            log('unknown command ' + repr(ctrl_msg['command']))
    elif topic == 'all':
        if ctrl_msg['command'] == 'quit':
            print ('Quitting')
            inport.close()
            exit(0)



def main():
    global pub_socket
    global ctrl_socket
    global subpoller
    global inport
    global inport_name

    inport = None
    inport_name = ""
    
    pub_socket = connect_publisher(args.data_bus_out)
    time.sleep(1)
    log("started")
    
    ctrl_socket = connect_subscriber(args.data_bus_in)
    subscribe(ctrl_socket, 'capturer')

    signal.signal(signal.SIGHUP, receiveSignal)
    
    subpoller = zmq.Poller()
    subpoller.register(ctrl_socket, zmq.POLLIN)
    
    try:
        if args.midi_port_in != None:
            inport = mido.open_input(args.midi_port_in)
            inport_name = args.midi_port_in
    except:
        msg = 'Error opening input port ' + args.midi_port_in
        print(msg)
        error(msg)
        exit(-1)

    # wait for the publisher to initialize before trying to send anything
    time.sleep(1)
    
    while 1:
        try:
            if inport != None:
                midi_message = inport.receive()
                send_rec_msg(pub_socket, midi_message)
            else:
                pass
        except KeyboardInterrupt:
            error('got exception: ' + repr(sys.exc_info()))
            exit(0)
        except:
            pass

args = parse_args()

if args.quiet:
    def print(*args):
        pass

main()
